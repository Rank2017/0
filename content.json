{"meta":{"title":"Artifact.","subtitle":null,"description":"A frog jumps into the pond, splash! Silence again.","author":"Art Chen","url":"http://artifact.me"},"pages":[{"title":"This is Art","text":"My name is Art Chen. I currently work for Amazon.Besides this blog, I also have a design portfolio at Rakugaki.me, and another blog at Otakism.com. Both sites are not actively updating."}],"posts":[{"title":"Universal Search #6 Baidu Search","text":"This is the 6th article in a series that covers the steps to add searching to Ghost, Hexo or any general website using APIs provided by various services.We have covered UI and common logics in the first article. This time we are going to explore Baidu Search.Since the service is all in Chinese, please refer to this article for content of this article.I quited on this. In short term there won’t be Baidu search support in the universal search series."},{"title":"Universal Search #5 Azure Search","text":"This is the 5th article in a series that covers the steps to add searching to Ghost, Hexo or any general website using APIs provided by various services.The latest version of Universal Search is available on Github at https://github.com/artchen/universal-search.We have covered UI and common logics in the first article. In this article we are going to explore Azure Search.Register for ServiceFirst of all, register an Azure account or just use your Microsoft account (outlook.com, hotmail.com, etc), and start your free trial.Go to the dashboard, and create a new service.Search “Azure Search”.Create a free Azure Search service. The creation might take a few minutes.Go to the control panel of your new Azure Search service. Choose Keys to reveal admin keys. Note down your primary admin key. We need this admin key to access the REST API.On the same panel, select “Manage query keys” and create a new query key. Note it down again. This query key will be used on the front-end to query your created index.Generate and upload dataJust like Algolia, Azure Search does not index your website automatically. Instead, it requires the users to create indexes and upload data.In this tutorial, I will use hexo-azuresearch, a plugin that I wrote, to demonstrate how to integrate Azure Search with Hexo. If your website is on other platforms, Azure provides detailed documentation about all the APIs it supports so it should not be too complicated to write your own indexer and data uploader.A heads up notice for non-English users, at this point I cannot get Azure Search to work with other languages. I will look into this issue.Hexonpm install --save hexo-azuresearchIn your global _config.yml, add the following configuration:In order for our front-end to work, you must include title, excerpt:strip and path. The other fields only help with searching accuracy.# Azure SearchAzureSearch: serviceURL: \"https://&lt;your-service-name&gt;.search.windows.net\" indexName: \"&lt;your-index-name&gt;\" adminKey: \"&lt;your-azure-search-admin-key&gt;\" analyzer: \"zh-Hans.lucene\" # optional fields: - title - excerpt:strip - content:strip - path - permalinkThen run the following command to index and upload data:hexo azuresearchGhostUnfortunately there is no existing support for Ghost.Build the classThis section is more of a development note. Plugin users don’t have to read it.The class for Azure Search is very similar to the one we built for Google Custom Search Engine. The only differences are the credentials and data formats.Enable your searchvar customSearch = new AzureSearch(&#123; serviceName: AZURE_SERVICE_NAME, indexName: AZURE_INDEX_NAME, queryKey: AZURE_QUERY_KEY&#125;);"},{"title":"Universal Search #4 Algolia Search","text":"This is the 4th article in a series that covers the steps to add searching to Ghost, Hexo or any general website using APIs provided by various services.The latest version of Universal Search is available on Github at https://github.com/artchen/universal-search.We have covered UI and common logics in the first article. This time we are going to explore Algolia, a wonderful tool to index your website.Create an indexFirst of all you need to register at www.algolia.com.Algolia will guide you to create the first application, you can choose a server location based on your target users.If a tutorial pops up, you can skip it. Go straight to create an index.Go to API Keys and find your credentials. You will need the Application ID, the Search-only API key and the Admin API key in the following sections.Generate and upload dataAlgolia requires users to upload their search index data either manually or via provided APIs. They provide many integration sdks available at https://www.algolia.com/integrations. Most of them are well documented.If your website have back-end (database, server logics, etc), most likely Algolia already provide an server-side client. Just go ahead and follow their instructions.If you are using a static site generator like Hexo, you might need to code a plugin so that every time you generate the site, the program will also upload a copy of index to Algolia. Currently the only official Algolia plugin for static site generator is Jekyll.I will only cover the integration with Hexo here since it is not yet officially supported.HexoInstall and configure hexo-algoliasearch in your Hexo directory. This plugin will index your site and upload selected data to Algolia.npm install --save hexo-algoliasearchIn your global _config.yml, add the following configuration:In order for our front-end javascript to work, you must include title, excerpt:strip and path. The other fields only help with searching accuracy.# Algoliaalgolia: appId: \"YOUR ALGOLIA APPLICATION ID\" apiKey: \"YOUR ALGOLIA SEARCH-ONLY API KEY\" adminApiKey: \"YOUR ALGOLIA ADMIN API KEY\" chunkSize: 5000 indexName: \"YOUR INDEX NAME\" fields: - title - excerpt:strip - path - content:strip - permalinkThen run the following command to upload data:hexo algoliaGhostUnfortunately there is no existing support for Ghost.Build the classThis section is more of a development note. Plugin users don’t have to read it.The class for Algolia is very similar to the one we built for Google Custom Search Engine. The only differences are the data formats.For consistency of UI, I didn’t use the javascript client provided by Algolia, which is implemented as autocomplete instant search.Enable your searchvar customSearch = new AlgoliaSearch(&#123; apiKey: ALGOLIA_API_KEY, appId: ALGOLIA_APP_ID, indexName: ALGOLIA_INDEX_NAME&#125;);"},{"title":"Universal Search #3 Hexo Local Search","text":"This is the 3rd article in a series that covers the steps to add searching to Ghost, Hexo or any general website using APIs provided by various services.The latest version of Universal Search is available on Github at https://github.com/artchen/universal-search.We have covered UI and common logics in the first article. This time we are going to explore Hexo local search. If you website is not generated by Hexo, you don’t necessarily need to read this article.Basic IdeaStatic site generator like Hexo does not rely on any database. Instead they pre-generate all pages and save them as individual html files. If we want to add search ability without using 3rd-party services, we will have to generate the “database” ourselves. In this case, the “database” is a index file that contains essential information of pages and posts. When the user submit a search request, the front-end javascript will download this index file, and searching for relevant items.Generate Index FileThere are several Hexo generators that does this for us. I use hexo-generator-json-content by alexbruno for this project.To install this plugin, first navigate to your Hexo directory, thennpm install --save hexo-generator-json-contentThen edit the global _config.yml, add the following configuration:jsonContent: meta: false keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish) pages: title: true slug: false date: false updated: false comments: false path: true link: false permalink: true excerpt: false keywords: false text: false raw: false content: true posts: title: true slug: false date: false updated: false comments: false path: true link: false permalink: true excerpt: false keywords: false text: false raw: false content: true categories: false tags: falseThe plugin should be good to go. From now on, every time hexo generate is executed, a content.json file will be generated in the public directory.Build the classThis section is more of a development note. Plugin users don’t have to read it.The class for Hexo local search is similar to the one we created for Google Custom Search Engine except this time we need a contentSearch(post, queryText) function to manually account for the keyword searching.I adopted this searching algorithm from http://hahack.com/codes/local-search-engine-for-hexo/. It was pretty simple and clean.Enable your searchInitialize an instance of the HexoSearch class:var customSearch = new HexoSearch(&#123; endpoint: \"&lt;path-to-your-content.json&gt;\" # optional&#125;);"},{"title":"Universal Search #2 Google Custom Search Engine","text":"This is the 2nd article in a series that covers the steps to add searching to Ghost, Hexo or any general website using APIs provided by various services.The latest version of Universal Search is available on Github at https://github.com/artchen/universal-search.We have covered UI and common logics in the previous article. This time we are going to integrate Google Custom Search Engine.Get Engine IDGo to https://cse.google.com. Click the add button.Go to next. Enter your website domain. Then click the create button.On the congratulations screen, click Control Panel.On the control panel, click Search Engine ID, note down the ID in the popup modal.Get API KeyGo to Google API Console. You may need to register first. Click ENABLE API.Search for “custom search”, click on the first result.On the Custom Search API page, click on Credential in the left side bar.On the Credential page, click create credential, then choose API Key.On the popup modal, choose Browser key.Name you API key and specify any URL wildcard as authorized referrers, then click create.You will be prompted the API key.Build the classThis section is more of a development note. Plugin users don’t have to read it.The GoogleCustomSearch class should inherit the SearchService class that we built in the previous article so that it has all the functions that control common data logics and the UI.There are only 3 functions to customize:buildResultList(data): traverse the result array, pass url, title and digest to the common buildResult() function to generate HTML markups.buildMetadata(data): generate metadata to enable pagination.query(queryText, startIndex, callback): send Ajax GET request to the Google Custom Search endpoint to get search results.In detail, we coded a class like this:Enable your searchIt should be as simple as initialize an instance of the GoogleCustomSearch class with your credentials:var customSearch = new GoogleCustomSearch(&#123; apiKey: GOOGLE_CUSTOM_SEARCH_API_KEY, engineId: GOOGLE_CUSTOM_SEARCH_ENGINE_ID&#125;);"},{"title":"Universal Search #1 Common Logic","text":"This is the 1st article in a series that covers the steps to add searching to Ghost, Hexo or any general website using APIs provided by various services.The goal of this series is to eventually create a javascript package that allows users to add searching to their websites by only copy-pasting code snippets and changing some configurations.I name the series “universal search” because these techniques are meant to work on any website. In reality, some of them require additional plugins to be installed, some of them may only apply to a few platforms. What I am trying to do here is to provide as many options as possible so that users can find at least one solution that works.Before readingThe latest version of Universal Search is available on Github at https://github.com/artchen/universal-search, feel free to clone and install.This article discusses my design of the plugin. If you only want to use it without knowing everything behind the scene, you can go ahead to one the of the following tutorials to setup individual search services:Google Custom Search EngineHexo Local Search - Hexo onlyAlgolia SearchAzure SearchBaidu SearchBasic WorkflowRegister a 3rd-party searching service, get the credentials (API Key, ID, etc).Send Ajax GET requests to some endpoint, get response in JSON format.Parse the response if necessary.Render the results on UI.Common UIThough I always advocate original and customized design, this time I am going to use the same common UI for some consistency. This interface is independent of whatever 3rd-party search service we choose.This markup will be compressed and embedded into the javascript. When the plugin is initialized, the markup will be inserted into &lt;body&gt;.Common LogicThe javascript part of universal search should take care of 3 main aspects:Query for search results.Parse results.Render UI.We already decided that the UI should be the same across services. So the following UI interactions should be defined as common functions.onSubmit(event): when the user submit the search form, open modal and query.onNextPage(): when the user request the next page, fetch next page.onPrevPage(): when the user request the previous page, fetch previous page.close(): when the user close the modal, fade out the modal.uiBeforeQuery(): hide the result container, show loading animation.uiAfterQuery(): hide loading animation, scroll result container to top, fade in the results.startLoading(): start the timer for loading bar animation.stopLoading(): stop the timer for loading bar animation.The query and parsing need to be defined on a per service basis because they apparently have different formats of API and response data. But we can centralize the following functions.onQueryError(queryText, status): empty result container, generate error messages and render in error container.buildResult(url, title, digest): generate html for one result.Most importantly, there should be init() and destroy():destroy(): unregister event handlers, clear markups.init(): register event handlers.All the functions listed above are common logics that goes into a super class called SearchService.Here is the result:These conclude the high level design and common part of universal search.You can now proceed to one of the following articles to integrate the search service of your choice:Google Custom Search EngineHexo Local Search - Hexo onlyAlgolia SearchAzure SearchBaidu Search"},{"title":"Hexo Theme Typescript","text":"Typescript is a minimal theme for Hexo.The theme is available on github at https://github.com/artchen/hexo-theme-typescriptThis theme is also available on:Ghost version: ghost-theme-typescriptDependenciesThis theme depends on the following Hexo plugins to work correctly:hexo-generator-taghexo-renderer-ejshexo-renderer-lesshexo-renderer-markedhexo-paginationPlease make sure these plugins are installed before generate the site.CustomizationTypescript is customizable via _config.yml file under the theme directory.The global _config.yml for Hexo may also be modified. In particular:Add/modify disqus_shortname field, the value set to your Disqus short nameChange theme field to hexo-theme-typescriptIn addition to these settings, users may also want to edit/replace the following files:Replace the site logo: source/images/logo.png, source/images/logo.psdThe search feature uses swiftype. Please follow their instruction to setup yours.The icon fonts are from icomoon.The default English font is Futura PT via Adobe Typekit. If you are using Typekit like me, please change the embedded javascript code in layout/_partial/head.ejs, else you can delete the corresponding code.DemoCopyrightPublic resources used in this theme:icomoonnormalize.cssfitvids.jsCopyright © Art ChenPlease do not remove the “Theme Typescript designed by Art Chen” text and links."},{"title":"Ghost Theme Typescript","text":"Typescript is a minimal theme for Ghost. I am working on a Hexo version, too.The theme is now available at https://github.com/artchen/ghost-theme-typescript.This theme is also available on:Hexo version: hexo-theme-typescriptProductionIf you are going to use Typescript directly (without much customization).cd &lt;path-to-ghost-folder&gt;/content/themes/git clone https://github.com/artchen/ghost-theme-typescript.git typescriptThe version shared via Github is used on otakism.org, my blog. There are quite a few things hard-coded into the template that you’ll need to customize. Including but not limited to:The site logo: assets/img/logo.pngThe short text under the logo: partials/header.hbsDisqus integration: page.hbs, post.hbsSocial account links: partials/footer.hbsThe search feature relies on swiftype. Please follow their instruction to setup your own searches.The fonts are from Typekit. If you are not using typekit, please remove corresponding code is in default.hbs.DevelopmentIf you are going to develop your own features/styles/etc upon Typescript, here is how to set up the development environment.Clone the repository.cd &lt;path-to-ghost-folder&gt;/content/themes/git clone https://github.com/artchen/ghost-theme-typescript.git typescriptInstall gulp, bower and npm before proceed.Install and build the app:cd ./typescriptnpm installbower installgulpAt this point your development environment is ready.Updatecd &lt;path-to-ghost&gt;/content/themes/typescript/git pullDemoVisit my blog (in Chinese) for a demo of tis theme. http://otakism.org.ScreenshotCopyrightPublic resources used in this theme:icomoonnormalize.cssCopyright © Art ChenPlease do not remove the “Theme Typescript designed by Art Chen” text and links."},{"title":"Simple Gulp Configuration for Angular Applications","text":"Gulp is a great build tool for web applications. In this article I am sharing some gulp scripts that I found really useful.Installing GulpNode.js needs to be installed prior to installing gulp. Once Node.js is ready on your machine, run this command to install gulp:sudo npm install --global gulp-cliThis will install the gulp command line tools globally, such that the gulp command can be invoked throughout the computer.Create a Gulp ProjectChange directory to the project’s root.npm initFirst of all, initialize npm, set the project name, version, author, etc. After the setup, package.json will be created.npm install gulp --save-devInstall gulp for the project. --save-dev make sure that gulp is logged in package.json as a development dependency. This is particularly useful when we need to port the project to another computer. With all the dependencies logged in package.json, we just run npm install to get them back, instead of install each of them again, or copy the gaint node_modules folder around.Project StructureFor an Angular.js application with gulp as the build tool, I usually setup the project directory like this:|- project/ |- bower_components/ |- dist/ |- node_modules/ |- src/ |- css/ # vendor css |- less/ # my less source code |- img/ |- js/ # my javascript source code |- vendor/ # vendor js |- views/ # angular templates |- index.html |- bower.json |- gulpfile.js |- package.jsonA simple gulpfile.jsHere comes the fun part. A basic gulpfile looks like this:// require gulp dependenciesvar gulp = require('gulp');// declare a gulp taskgulp.task('task_name', function() &#123; // task pipelines&#125;);The tasks can be run in command line like:gulp task_nameDefine PathsDefine a path object to keep track of all the source code in the project, making it easier for reference in various gulp tasks. For one of the angularjs application, I had the following paths:var path = &#123; // template markups HTML: [ 'src/*.html', 'src/views/**/*.html', 'src/views/*.html' ], // my js source code JS: [ 'src/js/**/*.js' 'src/js/*.js', ], // all less files (for changes monitoring purpose) LESS_ALL: [ 'src/less/*.less' ], // main less file (others are imported in style.less) LESS: [ 'src/less/style.less' ], // images IMG: [ 'src/img/**' ], // vendor css CSS: [ 'src/css/*.css' ], // vendor js VENDOR: [ 'bower_components/angular/angular.js', 'bower_components/angular-animate/angular-aria.js', // ...and more ], DIST: [ './dist' ]&#125;;Installing Gulp PluginsThere are tons of useful gulp plugins to explore. Gulp plugins can be installed bynpm install &lt;plugin-name&gt; --save-devFor example, to install gulp-connect:npm install gulp-connect --save-devUseful Gulp TasksHere I only introduce some gulp tasks that I found helpful in angularjs development.Spin up a erver for dist.var connect = require('gulp-connect');gulp.task('connect', function() &#123; connect.server(&#123; root: 'dist', port: 4000 &#125;);&#125;);Clean up distribution directory.var connect = require('gulp-clean');gulp.task('clean', function() &#123; return gulp.src('./dist/*', &#123;force: true&#125;) .pipe(clean());&#125;);Use JSLint.var jshint = require('gulp-jshint');gulp.task('lint', function() &#123; return gulp.src(path.JS) .pipe(jshint()) .pipe(jshint.reporter('default')) .pipe(jshint.reporter('fail'));&#125;);Copy over CSS and HTMLgulp.task('css', function () &#123; gulp.src(path.CSS) .pipe(gulp.dest(path.DIST + '/css'));&#125;);gulp.task('html', function () &#123; gulp.src(path.HTML, &#123;base: 'src'&#125;) .pipe(gulp.dest(path.DIST));&#125;);Compile, minify and copy Less.var less = require('gulp-less');var lessDependents = require('gulp-less-dependents');var minifyCSS = require('gulp-minify-css');gulp.task('less', function () &#123; gulp.src(path.LESS) .pipe(lessDependents()) .pipe(less()) .pipe(minifyCSS()) .pipe(gulp.dest(path.DIST + '/css'));&#125;);Merge, uglify and copy js files.var concat = require('gulp-concat');var uglify = require('gulp-uglify');var ngAnnotate = require('gulp-ng-annotate');var sourcemaps = require('gulp-sourcemaps');gulp.task('js', function () &#123; gulp.src(path.JS) .pipe(sourcemaps.init()) .pipe(concat('app.js')) .pipe(ngAnnotate()) .pipe(uglify()) .pipe(sourcemaps.write()) .pipe(gulp.dest(path.DIST + '/js'));&#125;);gulp.task('vendor', function () &#123; gulp.src(path.VENDOR) .pipe(concat('vendor.js')) .pipe(ngAnnotate()) .pipe(uglify()) .pipe(gulp.dest(path.DIST + '/js'));&#125;);Compress images.var imagemin = require('gulp-imagemin');gulp.task('img', function()&#123; gulp.src(path.IMG) .pipe(imagemin()) .pipe(gulp.dest(path.DIST + '/img'));&#125;);Watch changes and automate tasks.var watch = require('gulp-watch');gulp.task('watch', function () &#123; gulp.watch(path.LESS_ALL, ['less']); gulp.watch(path.VENDOR, ['vendor']); gulp.watch(path.JS, ['lint', 'js']); gulp.watch(path.HTML, ['html']); gulp.watch(path.IMG, ['img']);&#125;);Default task.var all_tasks = ['lint', 'css', 'less', 'vendor', 'js', 'html', 'img'];gulp.task('default', all_tasks);A More Complete gulpfile.js/* gulp dependencies */var gulp = require('gulp');var less = require('gulp-less');var watch = require('gulp-watch');var imagemin = require('gulp-imagemin');var connect = require('gulp-connect');var concat = require('gulp-concat');var sourcemaps = require('gulp-sourcemaps');var uglify = require('gulp-uglify');var ngAnnotate = require('gulp-ng-annotate');var minifyCSS = require('gulp-minify-css');var lessDependents = require('gulp-less-dependents');var clean = require('gulp-clean');var bower = require('gulp-bower');var concat_vendor = require('gulp-concat-vendor');var jshint = require('gulp-jshint');/* path def */var path = &#123; HTML: [ 'src/.htaccess', 'src/*.html', 'src/views/**/*.html', 'src/views/*.html', 'src/favicon.png' ], JS: [ 'src/js/*.js', 'src/js/**/*.js' ], CSS: [ 'src/css/*.css' ], LESS: [ 'src/less/style.less' ], LESS_ALL: [ 'src/less/*.less' ], IMG: [ 'src/img/**' ], VENDOR: [ 'bower_components/angular/angular.js', 'bower_components/angular-animate/angular-animate.js', 'bower_components/angular-aria/angular-aria.js', 'bower_components/angular-messages/angular-messages.js', 'bower_components/angular-sanitize/angular-sanitize.js', 'bower_components/angular-ui-router/release/angular-ui-router.js' // ...and more ], DIST: './dist'&#125;;/* spin up distribution server */gulp.task('connect', function() &#123; connect.server(&#123; root: 'dist', port: 4005 &#125;);&#125;);/* clean up dist dir */gulp.task('clean', function() &#123; return gulp.src('./dist/*', &#123;force: true&#125;) .pipe(clean());&#125;);/* jslint for debugging */gulp.task('lint', function() &#123; return gulp.src(path.JS) .pipe(jshint()) .pipe(jshint.reporter('default')) .pipe(jshint.reporter('fail'));&#125;);/* move css */gulp.task('css', function () &#123; gulp.src(path.CSS) .pipe(gulp.dest(path.DIST + '/css'));&#125;);/* compile less */gulp.task('less', function () &#123; gulp.src(path.LESS) .pipe(lessDependents()) .pipe(less()) .pipe(minifyCSS()) .pipe(gulp.dest(path.DIST + '/css'));&#125;);/* concat and compress app scripts */gulp.task('js', function () &#123; gulp.src(path.JS) .pipe(sourcemaps.init()) .pipe(concat('app.js')) .pipe(ngAnnotate()) .pipe(uglify()) .pipe(sourcemaps.write()) .pipe(gulp.dest(path.DIST + '/js'));&#125;);/* concat vendor dependencies */gulp.task('vendor', function () &#123; gulp.src(path.VENDOR) .pipe(concat('vendor.js')) .pipe(ngAnnotate()) .pipe(uglify()) .pipe(gulp.dest(path.DIST + '/js'));&#125;);/* copy over markups */gulp.task('html', function()&#123; gulp.src(path.HTML, &#123;base: 'src'&#125;) .pipe(gulp.dest(path.DIST));&#125;);/* compress images */gulp.task('img', function()&#123; gulp.src(path.IMG) .pipe(imagemin()) .pipe(gulp.dest(path.DIST + '/img'));&#125;);/* watch all changes */gulp.task('watch', function () &#123; gulp.watch(path.LESS_ALL, ['less']); gulp.watch(path.VENDOR, ['vendor']); gulp.watch(path.JS, ['lint', 'js']); gulp.watch(path.HTML, ['html']); gulp.watch(path.IMG, ['img']);&#125;);/* defualt */gulp.task('default', all_tasks);"},{"title":"Create Virtual Hosts on MAMP","text":"MAMP is a great GUI tool for creating server on localhost. But the free virsion of it only has very basic configurations. For example, creating a virtual host is not included. So I have to write the configurations on my own.This article is based on Windows OS. Setup on Mac OS should be similar.Why Virtual HostsQuestion: Why do we need to virtual hosts anyway? Answer: it simplifies your testing and developing. When developing a website, I want to visit it via something like http://test.local, rather than http://localhost/test/. The benefit of the former option is not just that it looks more like a real URL, or it is shorter. By creating test.local as the local domain, the root directory for your site is configured to any location your would like it to be, so there is no more hazard of nested path.Modify HostsFirst, add the desired domain to the system’s host file. It is located at C:\\Windows\\System32\\drivers\\etc\\hosts.Add this line:127.0.0.1 test.localYou can replace test.local with almost anything of your choice.Modify Apache ConfigurationModify C:\\MAMP\\conf\\apache\\httpd.conf.Find this line:# Virtual Hosts# Include /Applications/MAMP/conf/apache/extra/httpd-vhosts.confChange it to# Virtual HostsInclude C:\\MAMP\\conf\\apache\\httpd-vhosts.confCreate Virtual Host ConfigurationNow create the configuration file httpd-vhosts.conf.NameVirtualHost *:80&lt;VirtualHost *:80&gt; DocumentRoot 'C:\\MAMP\\htdocs' ServerName localhost&lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; DocumentRoot 'C:\\MAMP\\htdocs\\test' ServerName test.local&lt;/VirtualHost&gt;Start MAMP, your site should be available at http://test.local."},{"title":"Serve Ghost and Nginx on Ubuntu 14.04 LTS","text":"Recently I switched from Linode to DigitalOcean because of some rumor that Linode website is blocked in China. Here is a memo of how I migrated a Ghost blog, otakism.org.Some content came from several tutorials from DigitalOcean community. Credits are given at the end of this article.Install NginxInstall Nginx via apt-get.sudo apt-get updatesudo apt-get install nginxCreate Site DirectoriesI prefer /var/www as the root directory. To do that I created the following folders to hold my website files.sudo mkdir -p /var/www/rakugaki.me/htmlsudo mkdir -p /var/www/otakism.org/htmlsudo chown -R $USER:$USER /var/www/rakugaki.me/htmlsudo chown -R $USER:$USER /var/www/otakism.org/htmlsudo chmod -R 755 /var/wwwCreate Server Block FilesServer blocks configure ports and root directories for each website, as well as details about how they should be served.Here I used rakugaki.me as the default domain of my server.sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/rakugaki.mesudo vim /etc/nginx/sites-available/rakugaki.meChange the configuration like this:server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/rakugaki.me/html; index index.html index.htm; server_name rakugaki.me, www.rakugaki.me; location / &#123; try_files $uri $uri/ =404; &#125;&#125;Then I created the second server block file for otakism.org. Since it is a Ghost blog, the file should be like this:server &#123; listen 80; listen [::]:80; server_name otakism.org; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:2368; &#125;&#125;The files are done but we are not done. Enable the server block files.sudo ln -s /etc/nginx/sites-available/rakugaki.me /etc/nginx/sites-enabled/sudo ln -s /etc/nginx/sites-available/otakism.org /etc/nginx/sites-enabled/Delete the default site generated by Nginx.sudo rm /etc/nginx/sites-enabled/defaultRestart Nginx to apply new settings.sudo service nginx restartInstall GhostPrerequisites first. Ghost requires Node.js and npm. These can be installed in various ways. Refer to this article for more options.sudo apt-get updatesudo apt-get install nodejssudo apt-get install npmDownload Ghost. Details about the remaining steps in this chapter can be found in the official guide at Ghost.org.sudo apt-get updatesudo apt-get install zip wgetcd /var/www/otakism.org/htmlsudo wget https://ghost.org/zip/ghost-latest.zipsudo unzip -d ghost ghost-latest.zipInstall it.cd ghost/sudo npm install --productionConfigure GhostChange the url and/or port under production section.sudo cp config.example.js config.jssudo vim config.jsI also needed to migrate data, images and themes. Copy or replace them under content/.Keep Ghost RunningCreate upstart configurations to make the ghost blog start on system boot. In this way I can also manage my ghost blog as a service.sudo /etc/init/vim ghost-otakism.confPaste the following lines.# ghost-otakismstart on startupscript cd /var/www/otakism.org/html/ghost npm start --productionend scriptFinally I can summon my ghost.sudo service ghost-otakism startContents about Nginx setup credits to Justin Ellingwood, original post at How To Set Up Nginx Server Blocks (Virtual Hosts) on Ubuntu 14.04 LTS."},{"title":"Ruby on Rails Configuration on Mac OS X 10.11","text":"This is a memo of how to setup Ruby-on-Rails on Mac OS X 10.11. Especially, to get it work on RubyMine 8.0.3.The following process might not be the solution for everyone.Command-Line ToolsFirst of all, make sure developer command-line tools is installed.xcode-select --installIf it is already installed, expected output should be:xcode-select: error: command line tools are already installed, use \"Software Update\" to install updatesHomebrewInstall Homebrew:ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"Mac OS X 10.11 comes with version 2.0.0 of Ruby so this command should work.Then we can install almost all the packages we need via homebrew.RubyUse the officially recommended way to manage ruby versions with rbenv.brew install rbenv ruby-buildrbenv install 2.2.4rbenv global 2.2.4Check version:ruby -vDependenciesIf I remember correctly.brew updatebrew upgradebrew install libxml2 libxslt libiconvgem install nokogiri -- --use-system-libraries --with-xml2-include=/usr/include/libxml2 --with-xml2-lib=/usr/lib/brew install mysqlgem install mysql"},{"title":"Hexo Theme Fact","text":"Fact is a simple but powerful theme for Hexo. It comes with integration of tags, categories, archive and table-of-contents. The style design is inspired by V2EX.The theme is available on my Github as a public repository hexo-theme-fact.InstallationI assume you already have a Hexo blog initialized.cd &lt;path-to-hexo-folder&gt;/themesgit clone https://github.com/artchen/hexo-theme-fact.git factDon’t forget to modify _config.yml under root directory of Hexo blog. Change theme to Fact.theme: factConfigurationSome configuration can be found in _config.yml under the themes/fact directory.Updatecd &lt;path-to-hexo-folder&gt;/themes/factgit pullFontsI used Futura for text, and Inconsolata for source code. Both of them are hosted on Typekit.If you do not use Typekit, here are the necessary steps to switch to other services:In layout/_partial/head.ejs, delete the lines that include the typekit library, then include necessary files from your choice of web fonts (eg: Google Font).In source/css/_sass/style.scss, change the font macros to your choices.Screenshot"}]}